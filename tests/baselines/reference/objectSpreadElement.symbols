=== tests/cases/conformance/es6/destructuring/objectSpreadElement.ts ===
let o = { a: 1, b: 'no' }
>o : Symbol(o, Decl(objectSpreadElement.ts, 0, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 0, 9))
>b : Symbol(b, Decl(objectSpreadElement.ts, 0, 15))

let o2 = { b: 'yes', c: true }
>o2 : Symbol(o2, Decl(objectSpreadElement.ts, 1, 3))
>b : Symbol(b, Decl(objectSpreadElement.ts, 1, 10))
>c : Symbol(c, Decl(objectSpreadElement.ts, 1, 20))

let swap = { a: 'yes', b: -1 };
>swap : Symbol(swap, Decl(objectSpreadElement.ts, 2, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 2, 12))
>b : Symbol(b, Decl(objectSpreadElement.ts, 2, 22))

let addAfter: { a: number, b: string, c: boolean } =
>addAfter : Symbol(addAfter, Decl(objectSpreadElement.ts, 4, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 4, 15))
>b : Symbol(b, Decl(objectSpreadElement.ts, 4, 26))
>c : Symbol(c, Decl(objectSpreadElement.ts, 4, 37))

    { ...o, c: false }
>c : Symbol(c, Decl(objectSpreadElement.ts, 5, 11))

let addBefore: { a: number, b: string, c: boolean } =
>addBefore : Symbol(addBefore, Decl(objectSpreadElement.ts, 6, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 6, 16))
>b : Symbol(b, Decl(objectSpreadElement.ts, 6, 27))
>c : Symbol(c, Decl(objectSpreadElement.ts, 6, 38))

    { c: false, ...o }
>c : Symbol(c, Decl(objectSpreadElement.ts, 7, 5))

// Note: ignore still changes the order that properties are printed
let ignore: { a: number, b: string } =
>ignore : Symbol(ignore, Decl(objectSpreadElement.ts, 9, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 9, 13))
>b : Symbol(b, Decl(objectSpreadElement.ts, 9, 24))

    { b: 'ignored', ...o }
>b : Symbol(b, Decl(objectSpreadElement.ts, 10, 5))

let override: { a: number, b: string } =
>override : Symbol(override, Decl(objectSpreadElement.ts, 11, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 11, 15))
>b : Symbol(b, Decl(objectSpreadElement.ts, 11, 26))

    { ...o, b: 'override' }
>b : Symbol(b, Decl(objectSpreadElement.ts, 12, 11))

let nested: { a: number, b: boolean, c: string } =
>nested : Symbol(nested, Decl(objectSpreadElement.ts, 13, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 13, 13))
>b : Symbol(b, Decl(objectSpreadElement.ts, 13, 24))
>c : Symbol(c, Decl(objectSpreadElement.ts, 13, 36))

    { ...{ a: 3, ...{ b: false, c: 'overriden' } }, c: 'whatever' }
>a : Symbol(a, Decl(objectSpreadElement.ts, 14, 10))
>b : Symbol(b, Decl(objectSpreadElement.ts, 14, 21))
>c : Symbol(c, Decl(objectSpreadElement.ts, 14, 31))
>c : Symbol(c, Decl(objectSpreadElement.ts, 14, 51))

let combined: { a: number, b: string, c: boolean } =
>combined : Symbol(combined, Decl(objectSpreadElement.ts, 15, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 15, 15))
>b : Symbol(b, Decl(objectSpreadElement.ts, 15, 26))
>c : Symbol(c, Decl(objectSpreadElement.ts, 15, 37))

    { ...o, ...o2 }
let combinedBefore: { a: number, b: string, c: boolean } =
>combinedBefore : Symbol(combinedBefore, Decl(objectSpreadElement.ts, 17, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 17, 21))
>b : Symbol(b, Decl(objectSpreadElement.ts, 17, 32))
>c : Symbol(c, Decl(objectSpreadElement.ts, 17, 43))

    { b: 'ok', ...o, ...o2 }
>b : Symbol(b, Decl(objectSpreadElement.ts, 18, 5))

let combinedMid: { a: number, b: string, c: boolean } =
>combinedMid : Symbol(combinedMid, Decl(objectSpreadElement.ts, 19, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 19, 18))
>b : Symbol(b, Decl(objectSpreadElement.ts, 19, 29))
>c : Symbol(c, Decl(objectSpreadElement.ts, 19, 40))

    { ...o, b: 'ok', ...o2 }
>b : Symbol(b, Decl(objectSpreadElement.ts, 20, 11))

let combinedAfter: { a: number, b: string, c: boolean } =
>combinedAfter : Symbol(combinedAfter, Decl(objectSpreadElement.ts, 21, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 21, 20))
>b : Symbol(b, Decl(objectSpreadElement.ts, 21, 31))
>c : Symbol(c, Decl(objectSpreadElement.ts, 21, 42))

    { ...o, ...o2, b: 'ok' }
>b : Symbol(b, Decl(objectSpreadElement.ts, 22, 18))

let combinedNested: { a: number, b: boolean, c: string, d: string } =
>combinedNested : Symbol(combinedNested, Decl(objectSpreadElement.ts, 23, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 23, 21))
>b : Symbol(b, Decl(objectSpreadElement.ts, 23, 32))
>c : Symbol(c, Decl(objectSpreadElement.ts, 23, 44))
>d : Symbol(d, Decl(objectSpreadElement.ts, 23, 55))

    { ...{ a: 4, ...{ b: false, c: 'overriden' } }, d: 'actually new', ...{ a: 5, d: 'maybe new' } }
>a : Symbol(a, Decl(objectSpreadElement.ts, 24, 10))
>b : Symbol(b, Decl(objectSpreadElement.ts, 24, 21))
>c : Symbol(c, Decl(objectSpreadElement.ts, 24, 31))
>d : Symbol(d, Decl(objectSpreadElement.ts, 24, 51))
>a : Symbol(a, Decl(objectSpreadElement.ts, 24, 75))
>d : Symbol(d, Decl(objectSpreadElement.ts, 24, 81))

let combinedNestedChangeType: { a: number, b: boolean, c: number } =
>combinedNestedChangeType : Symbol(combinedNestedChangeType, Decl(objectSpreadElement.ts, 25, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 25, 31))
>b : Symbol(b, Decl(objectSpreadElement.ts, 25, 42))
>c : Symbol(c, Decl(objectSpreadElement.ts, 25, 54))

    { ...{ a: 1, ...{ b: false, c: 'overriden' } }, c: -1 }
>a : Symbol(a, Decl(objectSpreadElement.ts, 26, 10))
>b : Symbol(b, Decl(objectSpreadElement.ts, 26, 21))
>c : Symbol(c, Decl(objectSpreadElement.ts, 26, 31))
>c : Symbol(c, Decl(objectSpreadElement.ts, 26, 51))

let propertyNested: { a: { a: number, b: string } } =
>propertyNested : Symbol(propertyNested, Decl(objectSpreadElement.ts, 27, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 27, 21))
>a : Symbol(a, Decl(objectSpreadElement.ts, 27, 26))
>b : Symbol(b, Decl(objectSpreadElement.ts, 27, 37))

    { a: { ... o } }
>a : Symbol(a, Decl(objectSpreadElement.ts, 28, 5))

// accessors don't copy the descriptor
// (which means that readonly getters become read/write properties)
let op = { get a () { return 6 } };
>op : Symbol(op, Decl(objectSpreadElement.ts, 31, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 31, 10))

let getter: { a: number, c: number } =
>getter : Symbol(getter, Decl(objectSpreadElement.ts, 32, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 32, 13))
>c : Symbol(c, Decl(objectSpreadElement.ts, 32, 24))

    { ...op, c: 7 }
>c : Symbol(c, Decl(objectSpreadElement.ts, 33, 12))

getter.a = 12;
>getter.a : Symbol(a, Decl(objectSpreadElement.ts, 32, 13))
>getter : Symbol(getter, Decl(objectSpreadElement.ts, 32, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 32, 13))

// null and undefined are just skipped
let spreadNull: { a: number } =
>spreadNull : Symbol(spreadNull, Decl(objectSpreadElement.ts, 37, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 37, 17))

    { a: 7, ...null }
>a : Symbol(a, Decl(objectSpreadElement.ts, 38, 5))

let spreadUndefined: { a: number } =
>spreadUndefined : Symbol(spreadUndefined, Decl(objectSpreadElement.ts, 39, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 39, 22))

    { a: 7, ...undefined }
>a : Symbol(a, Decl(objectSpreadElement.ts, 40, 5))

// methods are not enumerable
class C { p = 1; m() { } }
>C : Symbol(C, Decl(objectSpreadElement.ts, 40, 26))
>p : Symbol(C.p, Decl(objectSpreadElement.ts, 43, 9))
>m : Symbol(C.m, Decl(objectSpreadElement.ts, 43, 16))

let c: C = new C()
>c : Symbol(c, Decl(objectSpreadElement.ts, 44, 3))
>C : Symbol(C, Decl(objectSpreadElement.ts, 40, 26))
>C : Symbol(C, Decl(objectSpreadElement.ts, 40, 26))

let spreadC: { p: number } = { ...c }
>spreadC : Symbol(spreadC, Decl(objectSpreadElement.ts, 45, 3))
>p : Symbol(p, Decl(objectSpreadElement.ts, 45, 14))

// new field's type conflicting with existing field is OK
let changeTypeAfter: { a: string, b: string } =
>changeTypeAfter : Symbol(changeTypeAfter, Decl(objectSpreadElement.ts, 48, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 48, 22))
>b : Symbol(b, Decl(objectSpreadElement.ts, 48, 33))

    { ...o, a: 'wrong type?' }
>a : Symbol(a, Decl(objectSpreadElement.ts, 49, 11))

let changeTypeBefore: { a: number, b: string } =
>changeTypeBefore : Symbol(changeTypeBefore, Decl(objectSpreadElement.ts, 50, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 50, 23))
>b : Symbol(b, Decl(objectSpreadElement.ts, 50, 34))

    { a: 'wrong type?', ...o };
>a : Symbol(a, Decl(objectSpreadElement.ts, 51, 5))

let changeTypeBoth: { a: string, b: number } =
>changeTypeBoth : Symbol(changeTypeBoth, Decl(objectSpreadElement.ts, 52, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 52, 21))
>b : Symbol(b, Decl(objectSpreadElement.ts, 52, 32))

    { ...o, ...swap };

// computed property
let computedFirst: { a: number, b: string, "before everything": number } =
>computedFirst : Symbol(computedFirst, Decl(objectSpreadElement.ts, 56, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 56, 20))
>b : Symbol(b, Decl(objectSpreadElement.ts, 56, 31))

    { ['before everything']: 12, ...o, b: 'yes' }
>'before everything' : Symbol(['before everything'], Decl(objectSpreadElement.ts, 57, 5))
>b : Symbol(b, Decl(objectSpreadElement.ts, 57, 38))

let computedMiddle: { a: number, b: string, c: boolean, "in the middle": number } =
>computedMiddle : Symbol(computedMiddle, Decl(objectSpreadElement.ts, 58, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 58, 21))
>b : Symbol(b, Decl(objectSpreadElement.ts, 58, 32))
>c : Symbol(c, Decl(objectSpreadElement.ts, 58, 43))

    { ...o, ['in the middle']: 13, b: 'maybe?', ...o2 }
>'in the middle' : Symbol(['in the middle'], Decl(objectSpreadElement.ts, 59, 11))
>b : Symbol(b, Decl(objectSpreadElement.ts, 59, 34))

let computedAfter: { a: number, b: string, "at the end": number } =
>computedAfter : Symbol(computedAfter, Decl(objectSpreadElement.ts, 60, 3))
>a : Symbol(a, Decl(objectSpreadElement.ts, 60, 20))
>b : Symbol(b, Decl(objectSpreadElement.ts, 60, 31))

    { ...o, b: 'yeah', ['at the end']: 14 }
>b : Symbol(b, Decl(objectSpreadElement.ts, 61, 11))
>'at the end' : Symbol(['at the end'], Decl(objectSpreadElement.ts, 61, 22))

// generics
function f<T, U>(t: T, u: U): { id: string, ...T, ...U } {
>f : Symbol(f, Decl(objectSpreadElement.ts, 61, 43))
>T : Symbol(T, Decl(objectSpreadElement.ts, 64, 11))
>U : Symbol(U, Decl(objectSpreadElement.ts, 64, 13))
>t : Symbol(t, Decl(objectSpreadElement.ts, 64, 17))
>T : Symbol(T, Decl(objectSpreadElement.ts, 64, 11))
>u : Symbol(u, Decl(objectSpreadElement.ts, 64, 22))
>U : Symbol(U, Decl(objectSpreadElement.ts, 64, 13))
>id : Symbol(id, Decl(objectSpreadElement.ts, 64, 31))
>T : Symbol(T, Decl(objectSpreadElement.ts, 64, 11))
>U : Symbol(U, Decl(objectSpreadElement.ts, 64, 13))

    return { id: 'id', ...t, ...u };
>id : Symbol(id, Decl(objectSpreadElement.ts, 65, 12))
}
let exclusive: { id: string, a: number, b: string, c: string, d: boolean } =
>exclusive : Symbol(exclusive, Decl(objectSpreadElement.ts, 67, 3))
>id : Symbol(id, Decl(objectSpreadElement.ts, 67, 16))
>a : Symbol(a, Decl(objectSpreadElement.ts, 67, 28))
>b : Symbol(b, Decl(objectSpreadElement.ts, 67, 39))
>c : Symbol(c, Decl(objectSpreadElement.ts, 67, 50))
>d : Symbol(d, Decl(objectSpreadElement.ts, 67, 61))

    f({ a: 1, b: 'yes' }, { c: 'no', d: false })
>f : Symbol(f, Decl(objectSpreadElement.ts, 61, 43))
>a : Symbol(a, Decl(objectSpreadElement.ts, 68, 7))
>b : Symbol(b, Decl(objectSpreadElement.ts, 68, 13))
>c : Symbol(c, Decl(objectSpreadElement.ts, 68, 27))
>d : Symbol(d, Decl(objectSpreadElement.ts, 68, 36))

let overlap: { id: string, a: number, b: string } =
>overlap : Symbol(overlap, Decl(objectSpreadElement.ts, 69, 3))
>id : Symbol(id, Decl(objectSpreadElement.ts, 69, 14))
>a : Symbol(a, Decl(objectSpreadElement.ts, 69, 26))
>b : Symbol(b, Decl(objectSpreadElement.ts, 69, 37))

    f({ a: 1 }, { a: 2, b: 'extra' })
>f : Symbol(f, Decl(objectSpreadElement.ts, 61, 43))
>a : Symbol(a, Decl(objectSpreadElement.ts, 70, 7))
>a : Symbol(a, Decl(objectSpreadElement.ts, 70, 17))
>b : Symbol(b, Decl(objectSpreadElement.ts, 70, 23))

let overlapConflict: { id:string, a: string } =
>overlapConflict : Symbol(overlapConflict, Decl(objectSpreadElement.ts, 71, 3))
>id : Symbol(id, Decl(objectSpreadElement.ts, 71, 22))
>a : Symbol(a, Decl(objectSpreadElement.ts, 71, 33))

    f({ a: 1 }, { a: 'mismatch' })
>f : Symbol(f, Decl(objectSpreadElement.ts, 61, 43))
>a : Symbol(a, Decl(objectSpreadElement.ts, 72, 7))
>a : Symbol(a, Decl(objectSpreadElement.ts, 72, 17))

let overwriteId: { id: boolean, a: number, c: number, d: string } =
>overwriteId : Symbol(overwriteId, Decl(objectSpreadElement.ts, 73, 3))
>id : Symbol(id, Decl(objectSpreadElement.ts, 73, 18))
>a : Symbol(a, Decl(objectSpreadElement.ts, 73, 31))
>c : Symbol(c, Decl(objectSpreadElement.ts, 73, 42))
>d : Symbol(d, Decl(objectSpreadElement.ts, 73, 53))

    f({ a: 1, id: true }, { c: 1, d: 'no' })
>f : Symbol(f, Decl(objectSpreadElement.ts, 61, 43))
>a : Symbol(a, Decl(objectSpreadElement.ts, 74, 7))
>id : Symbol(id, Decl(objectSpreadElement.ts, 74, 13))
>c : Symbol(c, Decl(objectSpreadElement.ts, 74, 27))
>d : Symbol(d, Decl(objectSpreadElement.ts, 74, 33))

class D { m() { }; q = 2; }
>D : Symbol(D, Decl(objectSpreadElement.ts, 74, 44))
>m : Symbol(D.m, Decl(objectSpreadElement.ts, 76, 9))
>q : Symbol(D.q, Decl(objectSpreadElement.ts, 76, 18))

let classesAreWrong: { id: string, ...C, ...D } =
>classesAreWrong : Symbol(classesAreWrong, Decl(objectSpreadElement.ts, 77, 3))
>id : Symbol(id, Decl(objectSpreadElement.ts, 77, 22))
>C : Symbol(C, Decl(objectSpreadElement.ts, 40, 26))
>D : Symbol(D, Decl(objectSpreadElement.ts, 74, 44))

    f(new C(), new D())
>f : Symbol(f, Decl(objectSpreadElement.ts, 61, 43))
>C : Symbol(C, Decl(objectSpreadElement.ts, 40, 26))
>D : Symbol(D, Decl(objectSpreadElement.ts, 74, 44))

