=== tests/cases/conformance/types/spread/objectSpreadIntersection.ts ===
function iteratedUnionIntersection<T, U, V>(t: T, u: U, v: V): void {
>iteratedUnionIntersection : Symbol(iteratedUnionIntersection, Decl(objectSpreadIntersection.ts, 0, 0))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))
>t : Symbol(t, Decl(objectSpreadIntersection.ts, 0, 44))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>u : Symbol(u, Decl(objectSpreadIntersection.ts, 0, 49))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>v : Symbol(v, Decl(objectSpreadIntersection.ts, 0, 55))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))

    let tu: T | U;
>tu : Symbol(tu, Decl(objectSpreadIntersection.ts, 1, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))

    let uv: U & V;
>uv : Symbol(uv, Decl(objectSpreadIntersection.ts, 2, 7))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))

    let result = { id: 'bar', ...tu, ...uv };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 3, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 3, 18))

    let expected: ({ id: string, ...T, ...U } & { id: string, ...T, ...V }) | ({ id: string, ...U } & { id: string, ...U, ...V });
>expected : Symbol(expected, Decl(objectSpreadIntersection.ts, 4, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 4, 20))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 4, 49))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 4, 80))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 4, 103))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))

    let assignable: { id: string, ...(T | U), ...(U & V) } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 5, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 5, 21))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 0, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 0, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 0, 40))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 3, 7))
}
// concrete types work
interface A1 { a: number }
>A1 : Symbol(A1, Decl(objectSpreadIntersection.ts, 6, 1))
>a : Symbol(A1.a, Decl(objectSpreadIntersection.ts, 8, 14))

interface A2 { a: string }
>A2 : Symbol(A2, Decl(objectSpreadIntersection.ts, 8, 26))
>a : Symbol(A2.a, Decl(objectSpreadIntersection.ts, 9, 14))

let a12: A1 & A2;
>a12 : Symbol(a12, Decl(objectSpreadIntersection.ts, 10, 3))
>A1 : Symbol(A1, Decl(objectSpreadIntersection.ts, 6, 1))
>A2 : Symbol(A2, Decl(objectSpreadIntersection.ts, 8, 26))

let result = { ...a12 };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 11, 3))

let sn: number & string = result.a;
>sn : Symbol(sn, Decl(objectSpreadIntersection.ts, 12, 3))
>result.a : Symbol(a, Decl(objectSpreadIntersection.ts, 8, 14), Decl(objectSpreadIntersection.ts, 9, 14))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 11, 3))
>a : Symbol(a, Decl(objectSpreadIntersection.ts, 8, 14), Decl(objectSpreadIntersection.ts, 9, 14))

let assignable: { ...(A1 & A2) } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 13, 3))
>A1 : Symbol(A1, Decl(objectSpreadIntersection.ts, 6, 1))
>A2 : Symbol(A2, Decl(objectSpreadIntersection.ts, 8, 26))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 11, 3))

function tripleIntersection<T, U, V>(t: T, u: U, v: V): void {
>tripleIntersection : Symbol(tripleIntersection, Decl(objectSpreadIntersection.ts, 13, 42))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))
>t : Symbol(t, Decl(objectSpreadIntersection.ts, 15, 37))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>u : Symbol(u, Decl(objectSpreadIntersection.ts, 15, 42))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>v : Symbol(v, Decl(objectSpreadIntersection.ts, 15, 48))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))

    let tuv: T & U & V;
>tuv : Symbol(tuv, Decl(objectSpreadIntersection.ts, 16, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))

    let result = { id: 'foo', ...tuv };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 17, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 17, 18))

    let expected: { id: string, ...T } & { id: string, ...U } & { id: string, ...V } = result;
>expected : Symbol(expected, Decl(objectSpreadIntersection.ts, 18, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 18, 19))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 18, 42))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 18, 65))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 17, 7))

    let assignable: { id: string, ...(T & U & V) } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 19, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 19, 21))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 15, 28))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 15, 30))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 15, 33))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 17, 7))
}
function iteratedDoubleIntersection<T, U, V>(t: T, u: U, v: V): void {
>iteratedDoubleIntersection : Symbol(iteratedDoubleIntersection, Decl(objectSpreadIntersection.ts, 20, 1))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))
>t : Symbol(t, Decl(objectSpreadIntersection.ts, 21, 45))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>u : Symbol(u, Decl(objectSpreadIntersection.ts, 21, 50))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>v : Symbol(v, Decl(objectSpreadIntersection.ts, 21, 56))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))

    let tu: T & U;
>tu : Symbol(tu, Decl(objectSpreadIntersection.ts, 22, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))

    let uv: U & V;
>uv : Symbol(uv, Decl(objectSpreadIntersection.ts, 23, 7))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))

    let result = { id: 'bar', ...tu, ...uv };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 24, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 24, 18))

    let expected: { id: string, ...T, ...U } & { id: string, ...T, ...V } & { id: string, ...U } & { id: string, ...U, ...V };
>expected : Symbol(expected, Decl(objectSpreadIntersection.ts, 25, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 25, 19))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 25, 48))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 25, 77))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 25, 100))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))

    let assignable: { id: string, ...(T & U), ...(U & V) } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 26, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 26, 21))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 21, 36))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 21, 38))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 21, 41))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 24, 7))
}
function iteratedIntersectionUnion<T, U, V>(t: T, u: U, v: V): void {
>iteratedIntersectionUnion : Symbol(iteratedIntersectionUnion, Decl(objectSpreadIntersection.ts, 27, 1))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))
>t : Symbol(t, Decl(objectSpreadIntersection.ts, 28, 44))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>u : Symbol(u, Decl(objectSpreadIntersection.ts, 28, 49))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>v : Symbol(v, Decl(objectSpreadIntersection.ts, 28, 55))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))

    let tu: T & U;
>tu : Symbol(tu, Decl(objectSpreadIntersection.ts, 29, 7))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))

    let uv: U | V;
>uv : Symbol(uv, Decl(objectSpreadIntersection.ts, 30, 7))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))

    let result = { id: 'bar', ...tu, ...uv };
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 31, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 31, 18))

    let expected: ({ id: string, ...T, ...U } & { id: string, ...U }) | ({ id: string, ...T, ...V } & { id: string, ...U, ...V });
>expected : Symbol(expected, Decl(objectSpreadIntersection.ts, 32, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 32, 20))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 32, 49))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 32, 74))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 32, 103))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))

    let assignable: { id: string, ...(T & U), ...(U | V) } = result;
>assignable : Symbol(assignable, Decl(objectSpreadIntersection.ts, 33, 7))
>id : Symbol(id, Decl(objectSpreadIntersection.ts, 33, 21))
>T : Symbol(T, Decl(objectSpreadIntersection.ts, 28, 35))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>U : Symbol(U, Decl(objectSpreadIntersection.ts, 28, 37))
>V : Symbol(V, Decl(objectSpreadIntersection.ts, 28, 40))
>result : Symbol(result, Decl(objectSpreadIntersection.ts, 31, 7))
}


